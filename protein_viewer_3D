# --- Standard- und externe Bibliotheken einbinden ---
import os, tempfile                            # Für Dateipfade und temporäre Dateien
import numpy as np                             # Numerische Operationen und Arrays
import streamlit as st                         # Interaktive Weboberfläche
from Bio.PDB import PDBParser                  # PDB-Dateien analysieren (Proteinstrukturen)
from periodictable import elements             # Periodensystem mit Atom-Massen etc.
import plotly.graph_objects as go              # 3D-Datenvisualisierung
from collections import defaultdict            # Vereinfachte Gruppierung von Daten

# --- Datenstruktur-Klassen für Proteinaufbau ---

class Atom:
    def __init__(self, element, coord):
        self.element = element.strip().capitalize()  # z. B. "C", "O", "N" (standardisiert)
        self.coord = coord                            # 3D-Koordinaten (x, y, z)

    def get_mass(self):
        # Gibt Atommasse zurück, falls bekannt – sonst 0.0
        try:
            return getattr(elements, self.element).mass
        except AttributeError:
            return 0.0

class Residue:
    def __init__(self, name):
        self.name = name        # z. B. "ALA", "GLY"
        self.atoms = []         # Liste von Atomen im Residuum

    def add_atom(self, atom):
        self.atoms.append(atom)

class Chain:
    def __init__(self, chain_id):
        self.chain_id = chain_id   # z. B. "A", "B"
        self.residues = []         # Liste von Residuen

    def add_residue(self, residue):
        self.residues.append(residue)

class Protein:
    def __init__(self, name):
        self.name = name          # Dateiname bzw. PDB-Titel
        self.chains = []          # Liste von Ketten

    def add_chain(self, chain):
        self.chains.append(chain)

    def get_all_atoms(self):
        # Gibt alle Atome des Proteins in einer Liste zurück
        return [atom for chain in self.chains for res in chain.residues for atom in res.atoms]

    def calculate_molecular_weight(self):
        # Gesamtmasse des Proteins (Summe aller Atom-Massen)
        return sum(atom.get_mass() for atom in self.get_all_atoms())

# --- PDB-Verarbeitung ---

def extract_title_from_pdb(file_path):
    # Versucht, den Titel aus der PDB-Datei auszulesen
    with open(file_path, 'r') as f:
        for line in f:
            if line.startswith("TITLE"):
                return line[10:].strip().capitalize()
    return "Unbekannter Proteinname"

def parse_pdb(pdb_file):
    # PDB-Datei parsen → Proteinstruktur aufbauen
    parser = PDBParser(QUIET=True)
    structure = parser.get_structure("protein", pdb_file)
    protein = Protein(os.path.basename(pdb_file))

    for model in structure:
        for chain in model:
            c = Chain(chain.id)
            for residue in chain:
                r = Residue(residue.resname)
                for atom in residue:
                    a = Atom(atom.element, atom.coord)
                    r.add_atom(a)
                c.add_residue(r)
            protein.add_chain(c)
    return protein

# --- 3D-Visualisierung mit Filterlogik ---

def visualize_protein_3d(protein, selected_chains, selected_elements, selected_residues, color_mode, protein_title):
    atoms_highlighted = defaultdict(list)  # Gruppierung farbiger Atome
    atoms_background = []                  # Restliche (graue) Atome

    # Farbpalette für Residuen (bei Bedarf)
    color_palette = [
        'red', 'blue', 'green', 'orange', 'purple', 'cyan', 'magenta', 'lime', 'yellow', 'pink',
        'gold', 'brown', 'gray', 'olive', 'teal', 'navy', 'maroon', 'aqua', 'indigo', 'violet'
    ]
    residue_colors = {}
    color_index = 0

    # --- Atome in Highlight oder Hintergrund einteilen ---
    for chain in protein.chains:
        for residue in chain.residues:
            if color_mode == "Nach Residuum" and residue.name not in residue_colors:
                # Farbzuweisung für Residuum
                residue_colors[residue.name] = color_palette[color_index % len(color_palette)]
                color_index += 1
            for atom in residue.atoms:
                match_chain = chain.chain_id in selected_chains if selected_chains else True
                match_element = atom.element in selected_elements if selected_elements else True
                match_residue = residue.name in selected_residues if selected_residues else True

                if match_chain and match_element and match_residue:
                    # Farbig hervorheben
                    if color_mode == "Nach Kette":
                        key = chain.chain_id
                    elif color_mode == "Nach Element":
                        key = atom.element
                    elif color_mode == "Nach Residuum":
                        key = residue.name
                    else:
                        key = "highlight"
                    atoms_highlighted[key].append(atom.coord)
                else:
                    # Graue Darstellung für alles andere
                    atoms_background.append(atom.coord)

    # Farbtabellen für Ketten/Elemente
    element_colors = {
        'H': 'white', 'C': 'green', 'N': 'blue', 'O': 'red', 'S': 'yellow',
        'P': 'orange', 'Fe': 'darkgray', 'Zn': 'purple', 'Cl': 'green',
        'Na': 'deepskyblue', 'K': 'violet', 'Ca': 'limegreen', 'Mg': 'teal'
    }
    chain_colors = {
        cid: col for cid, col in zip(
            sorted(set(chain.chain_id for chain in protein.chains)),
            ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']
        )
    }

    # --- 3D-Plot erstellen ---
    fig = go.Figure()

    # Hintergrund (graue) Atome
    if atoms_background:
        bg_coords = np.array(atoms_background)
        fig.add_trace(go.Scatter3d(
            x=bg_coords[:, 0], y=bg_coords[:, 1], z=bg_coords[:, 2],
            mode='markers',
            marker=dict(size=3, color='lightgray', opacity=0.3),
            name='Andere'
        ))

    # Farbig hervorgehobene Atome
    for key, coords in atoms_highlighted.items():
        coords = np.array(coords)
        if len(coords) == 0:
            continue

        if color_mode == "Nach Kette":
            color = chain_colors.get(key, 'gray')
        elif color_mode == "Nach Element":
            color = element_colors.get(key, 'black')
        elif color_mode == "Nach Residuum":
            color = residue_colors.get(key, 'gold')
        else:
            color = 'orange'

        fig.add_trace(go.Scatter3d(
            x=coords[:, 0], y=coords[:, 1], z=coords[:, 2],
            mode='markers',
            marker=dict(size=4, color=color),
            name=str(key)  # Nur Name anzeigen, ohne Zusatztext wie "Kette"
        ))

    # --- Layout anpassen ---
    fig.update_layout(
        title=f'3D Struktur: {protein_title}',
        width=800, height=700,
        scene=dict(
            xaxis=dict(title='X'),
            yaxis=dict(title='Y'),
            zaxis=dict(title='Z')
        ),
        margin=dict(l=0, r=0, b=0, t=40),
        legend=dict(itemsizing='constant'),
    )

    # Reset-Knopf für Kamera
    if st.button("Ansicht zurücksetzen"):
        fig.update_layout(scene_camera=dict(eye=dict(x=1.5, y=1.5, z=1.5)))

    # Export als HTML-Datei
    with tempfile.NamedTemporaryFile(delete=False, suffix=".html") as tmp_html:
        fig.write_html(tmp_html.name)
        st.download_button(
            label="3D-Visualisierung als HTML speichern",
            data=open(tmp_html.name, 'rb').read(),
            file_name='protein_visualisierung.html',
            mime='text/html'
        )

    # Plot anzeigen
    st.plotly_chart(fig, use_container_width=True)

# --- Streamlit-Oberfläche ---

def run_gui():
    st.title("Proteinstruktur-Analyse")

    # Datei-Upload
    uploaded_file = st.file_uploader("Wähle eine PDB-Datei", type="pdb")
    if uploaded_file:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdb") as tmp:
            tmp.write(uploaded_file.read())
            tmp_path = tmp.name

        # Protein verarbeiten
        protein = parse_pdb(tmp_path)
        title = extract_title_from_pdb(tmp_path)
        weight = protein.calculate_molecular_weight()

        # Basis-Infos
        st.info(f"**Proteinname:** {title}")
        st.success(f"Molekulargewicht: {weight:.2f} Da")

        # Filteroptionen
        all_chains = sorted(set(chain.chain_id for chain in protein.chains))
        all_elements = sorted(set(atom.element for atom in protein.get_all_atoms()))
        all_residues = sorted(set(res.name for chain in protein.chains for res in chain.residues))

        selected_chains = st.multiselect("Ketten auswählen:", all_chains, default=all_chains)
        selected_elements = st.multiselect("Elemente auswählen:", all_elements, default=all_elements)
        selected_residues = st.multiselect("Residuen auswählen:", all_residues, default=all_residues)

        # Farbmodus
        color_mode = st.radio("Farbmodus", ["Nach Kette", "Nach Element", "Nach Residuum"], horizontal=True)

        # 3D-Ansicht
        st.write("### 3D-Struktur")
        visualize_protein_3d(protein, selected_chains, selected_elements, selected_residues, color_mode, title)

# --- Startpunkt der Anwendung ---
if __name__ == '__main__':
    run_gui()
